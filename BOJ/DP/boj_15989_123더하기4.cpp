#include <iostream>

using namespace std;

/*
<문제>
정수 n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하라
순서만 다른 것은 같은 것으로 친다.

0 <= n <= 10000

<접근>
1. 완전탐색 재귀 -> O(3^n) -> O(3^10000) -> 시간초과 될듯
2. dp -> O()

순서만 다른 것은 같은 것으로 치므로
더하는 숫자를 이전에 더했던 순서 보다 크거나 같은 것만 더해주기로 (오름차순 처럼)
or 더하는 숫자를 이전에 더했던 순서 보다 작거나 같은 것만 더해주기로 (내림차순 처럼)

---------------------------------------------(오름차순)---------------------------------------------
dp[i][1] -> 1로 시작해 1보다 크거나 같은 수의 합 순서로만 i를 만드는 경우
dp[i][2] -> 2로 시작해 2보다 크거나 같은 수의 합 순서로만 i를 만드는 경우
dp[i][3] -> 3으로 시작해 3보다 크거나 같은 수의 합 순서로만 i를 만드는 경우 -> 항상 1이거나 없거나

n을 만드는 경우의 수 = dp[i][1] + dp[i][2] + dp[i][3]


=> 올림차순으로 찾으니 위에서 dp[i][3] 경우에 3의 배수이거나 배수가 아닐때로 나눠줘야 함
=> 뭔가 복잡해보이니 내림차순으로 해보자


---------------------------------------------(내림차순)---------------------------------------------
dp[i][1] -> 1로 시작해 1보다 작거나 같은 수의 합 순서로만 i를 만드는 경우 -> 항상 1가지
dp[i][2] -> 2로 시작해 2보다 작거나 같은 수의 합 순서로만 i를 만드는 경우
dp[i][3] -> 3으로 시작해 3보다 작거나 같은 수의 합 순서로만 i를 만드는 경우

dp[4][1] = (1+1+1+1) -> 앞에 1을 떼면 3을 만드는 경우의 수와 같다 -> (1+1+1)    -> dp[3][1]
dp[4][2] = (2+2) (2+1+1) -> 앞에 2를 뗴면                   -> (2) (1+1)  -> dp[2][2] + dp[2][1]
dp[4][3] = (3+1) -> 앞에 3을 떼면                           -> (1)        -> dp[1][1] + (dp[1][2] + dp[1][3])


=>
dp[i][1] = dp[i-1][1]
dp[i][2] = dp[i-2][2] + dp[i-2][1]
dp[i][3] = dp[i-3][1] + dp[i-3][2] + dp[i-3][3]
*/

#define Max 10001
int dp[Max][4];

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    for (int i = 1; i < 10001; i++)
    {
        dp[i][1] = 1; // dp[i][1] -> 1보다 작거나 같은 수의 합 순서로만 i를 만드는 경우 -> 항상 1가지
    }

    dp[1][2] = 0;
    dp[1][3] = 0;

    dp[2][2] = 1;
    dp[2][3] = 0;

    dp[3][2] = 1;
    dp[3][3] = 1;

    for (int i = 4; i < 10001; i++)
    {
        dp[i][1] = dp[i - 1][1];
        dp[i][2] = dp[i - 2][2] + dp[i - 2][1];
        dp[i][3] = dp[i - 3][1] + dp[i - 3][2] + dp[i - 3][3];
    }

    int test_case;
    cin >> test_case;
    while (test_case--)
    {
        int n;
        cin >> n;

        cout << dp[n][1] + dp[n][2] + dp[n][3] << '\n';
    }

    return 0;
}